# -*- coding: utf-8 -*-
"""Decision Tree.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19D-B346w9ZPwarFyON12QCYoN7kZeNBv

Khai báo thư viện
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler, RobustScaler, StandardScaler
from sklearn.preprocessing import LabelEncoder, OneHotEncoder, OrdinalEncoder
from sklearn import model_selection

"""Đọc dữ liệu"""

#loading dataset and running some basic methods to know more about the dataset
df = pd.read_csv('/content/drive/MyDrive/N6-KPDL/DATA/Fraud_100000.csv')

#shape of the dataset
print('Số lượng mẫu của bộ dữ liệu là:', df.shape[0])
print('Số lượng thuộc tính của bộ dữ liệu là:', df.shape[1])

"""Hiển thị 5 dòng dữ liệu đầu"""

#first five rows of the dataset
df.head()

"""Hiển thị 5 dòng dữ liệu cuối"""

#bottom five rows of the dataset
df.tail()

"""Kiểm tra dữ liệu khuyết thiếu"""

from google.colab import drive
drive.mount('/content/drive')

df.isna()

#checking for any null or missing values
df.isnull().sum()

"""Xử lý giá trị khuyết thiếu

1. Thay thế các giá trị khuyết thiếu bằng giá trị trung bình
"""

df_filled = df.fillna(df.mean())

"""2. Xóa các giá trị khuyết thiếu"""

drop_df = df.dropna()
print(drop_df)

"""3. Kiểm tra dữ liệu trùng lặp dữ liệu"""

#checking for any duplicate data
df[df.duplicated()]

"""Thống kê các giá trị định lượng"""

#information regarding numerical columns
df.describe()

df.columns

"""Xử lý ngoại lai

1. Vẽ biểu đồ Boxplot

Đổi dữ liệu từ dạng định danh (object) về dạng số:
"""

from sklearn.preprocessing import LabelEncoder
lb_make = LabelEncoder()
df['type'] = lb_make.fit_transform(df['type'])
df['nameOrig'] = lb_make.fit_transform(df['nameOrig'])
df['nameDest'] = lb_make.fit_transform(df['nameDest'])
df.info() # tái kiểm tra thuộc tính

new_cols = [col for col in df.columns if col in ['step', 'type', 'amount', 'nameOrig', 'oldbalanceOrg', 'newbalanceOrig', 'nameDest', 'oldbalanceDest', 'newbalanceDest']]
df1 = df[new_cols]
red_circle = dict(markerfacecolor = 'red', marker = 'o', markeredgecolor = 'white') # tô màu đỏ cho các điểm ngoại lai trong đồ thị
fig, axs = plt.subplots(1, len(new_cols), figsize=(30,10)) # chuyền số cột df.columns với kích thước figsize=(30,10)
for i, ax in enumerate(axs.flat): # dùng vòng lặp for nhận tất cả các hàng từ khung dữ liệu cho các cột
        ax.boxplot(df1.iloc[:,1], flierprops=red_circle)
        ax.set_title(new_cols[i], fontsize=20, fontweight='bold') # thiết lập size và kiểu chữ cho tiêu đề
        ax.tick_params(axis='y', labelsize=14)
plt.tight_layout() # tạo khoảng trống cho các ô

"""Nhận xét:
Từ biểu đồ boxplot ta thấy các thuộc tính : ... có các giá trị ngoại lai.

2. Xử lý giá trị ngoại lai:
Có 2 hàm dưới đây để xử lý các giá trị ngoại lệ bằng các quy tắc sau:
- Tất cả các giá trị nhỏ hơn Lower Whisker sẽ được gán giá trị của Lower_whisker
- Tất cả các giá trị trên Upper Whisker sẽ được gán giá trị của Upper_Whisker
"""

def treat_outliers(df, col):
    Q1=df[col].quantile(0.25) # 25th quantile
    Q3=df[col].quantile(0.75) # 75th quantile
    IQR=Q3-Q1
    Lower_Whisker = Q1 - 1.5*IQR
    Upper_Whisker = Q3 + 1.5*IQR
    df[col] = np.clip(df[col], Lower_Whisker, Upper_Whisker)
    return df
def treat_outliers_all(df, col_list): # Loại bỏ giá trị ngoại lệ
    for a in col_list:
        df = treat_outliers(df,a)
    return df

"""3. Thực hiện loại bỏ giá trị ngoại lai"""

new_cols = [col for col in df.columns if col in ['step', 'type', 'amount', 'nameOrig', 'oldbalanceOrg', 'newbalanceOrig', 'nameDest', 'oldbalanceDest', 'newbalanceDest']]
# Xử lý ngoại lai
df = treat_outliers_all(df,new_cols)

"""* Vẽ biểu đồ Boxplot các giá trị ngoại lai đã được loại bỏ:"""

new_cols = [col for col in df.columns if col in ['step', 'type', 'amount', 'nameOrig', 'oldbalanceOrg', 'newbalanceOrig', 'nameDest', 'oldbalanceDest', 'newbalanceDest']]
df1 = df[new_cols]
red_circle = dict(markerfacecolor = 'red', marker = 'o', markeredgecolor = 'white') # tô màu đỏ cho các điểm ngoại lai trong đồ thị
fig, axs = plt.subplots(1, len(new_cols), figsize=(30,10)) # chuyền số cột df.columns với kích thước figsize=(30,10)
for i, ax in enumerate(axs.flat): # dùng vòng lặp for nhận tất cả các hàng từ khung dữ liệu cho các cột
        ax.boxplot(df1.iloc[:,1], flierprops=red_circle)
        ax.set_title(new_cols[i], fontsize=20, fontweight='bold') # thiết lập size và kiểu chữ cho tiêu đề
        ax.tick_params(axis='y', labelsize=14)
plt.tight_layout() # tạo khoảng trống cho các ô

"""4. Lưu file dữ liệu sau khi xử lý"""

df.to_csv('/content/drive/MyDrive/N6-KPDL/DATA/Fraud_100000_tienxuly.csv', encoding='utf-8', index=False)

df

"""Đọc file dữ liệu mới"""

df1 = pd.read_csv('/content/drive/MyDrive/N6-KPDL/DATA/Fraud_100000_tienxuly.csv', engine = 'python', header=0, delimiter=',')
df1

"""Hiển thị kiểu dữ liệu của các thuộc tính:"""

df.dtypes

#information about the columns and their datatypes
df.info()

"""# Thuật toán Decision Tree

"""

# Đọc file dữ liệu mới
df1 = pd.read_csv('/content/drive/MyDrive/KPDL_Data/N6-KPDL/DATA/Fraud_100000_tienxuly.csv', engine = 'python', header=0, delimiter=',')
df1

#Hiển thị kiểu dữ liệu các thuộc tính
df1.dtypes

#Xem dữ liệu isFraud
df1['isFraud'].value_counts()

max_value = df1['amount'].max()
min_value = df1['amount'].min()
mean_value = df1['amount'].mean()

print(f'Giá trị cao nhất: {max_value}')
print(f'Giá trị thấp nhất: {min_value}')
print(f'Giá trị trung bình: {mean_value}')

# Chuyển dữ liệu từ các cột sang dạng rời rạc gồm 3 giá trị : Low, Medium, High
df1['oldbalanceOrg_pt'] = pd.qcut(df1['oldbalanceOrg'], 3, labels=['bottom', 'middle', 'top'])
df1['oldbalanceDest_pt'] = pd.qcut(df1['oldbalanceDest'],4 , labels=['bottom','middle', 'top'], duplicates='drop')
df1['newbalanceDest_qt'] = pd.qcut(df1['newbalanceDest'], 4, labels=['bottom', 'middle', 'top'], duplicates='drop')

#Chuyển dữ liệu cột amount từ liên tục sang rời rạc gồm 3 giá trị: Low, Medium, High
cut_labels = ['Low', 'Medium', 'High']
cut_bins = [0.3, 7000, 140000, 500728.27375] #0,3 là giá trị min, 500728.27375 là giá trị max của amount
df1['amount_label'] = pd.cut(df['amount'], bins = cut_bins, labels = cut_labels)

df1

#Xóa cột amount, step, oldbalanceOrg, oldbalanceDest, newbalanceDest
df1.drop('amount', axis =1, inplace = True)
df1.drop('oldbalanceOrg', axis =1, inplace = True)
df1.drop('oldbalanceDest', axis =1, inplace = True)
df1.drop('newbalanceDest', axis =1, inplace = True)

df1

df1['amount_label'] = lb_make.fit_transform(df1['amount_label'])
df1['oldbalanceOrg_pt'] = lb_make.fit_transform(df1['oldbalanceOrg_pt'])
df1['oldbalanceDest_pt'] = lb_make.fit_transform(df1['oldbalanceDest_pt'])
df1['newbalanceDest_qt'] = lb_make.fit_transform(df1['newbalanceDest_qt'])
df1.info() # tái kiểm tra thuộc tính

#Chuẩn bị dữ liệu để train model
features =['step', 'type', 'amount_label', 'newbalanceDest_qt','oldbalanceDest_pt', 'oldbalanceOrg_pt', 'newbalanceOrig']
target = ['isFraud']
x = df1[features]
y = df1[target]

#In ra mảng dữ liệu
print(x.shape)
print(y.shape)

#Khai báo thư viện
from sklearn.model_selection import train_test_split
#Xây dựng mô hình
x_train, x_test, y_train, y_test = train_test_split (x, y, random_state = 100, test_size=0.1) # Chia tập dữ liệu làm 2 tập train và test với test size là 20%

#Xây dựng cây
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import confusion_matrix

model_mytree = DecisionTreeClassifier()
model_mytree.fit(x_train, y_train)

#Dự đoán trên dữ liệu test
y_pred = model_mytree.predict(x_test)

#In ra kết quả
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score
print("Accuracy: ", accuracy_score(y_test, y_pred)*100)
print("Ma trận nhầm lẫn")
print(confusion_matrix(y_test, y_pred))
print('\n')
print("Báo cáo phân loại")
print(classification_report(y_test, y_pred))
print('\n')